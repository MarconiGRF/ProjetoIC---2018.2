const fs = require('fs');

exports.solve = function (filename) {
  let formula = readFormula(filename)

  if(typeof(formula) == 'string'){
    console.log("Erro de especificação do arquivo .cnf")
  }
  else{
    let assignment = formula.variables
    let result = doSolve(formula.clauses, formula.variables)

   // if(result == false){
   //   console.log(result)
   // }
    //else{
    console.log('isSat:'+result.isSat+',', 'satisfyingAssignment:{'+result.satisfyingAssignment+'}')
    //}
    return result
  }
}

function doSolve(clauses, assignment) {
  let last = false
  let isSat = false
  while ((!isSat) && !(last)) {
    last = true
    for(let i = 0; (i<assignment.length) && (last); i++){
      if(assignment[i]==0){
        last = false
      }
    }
    let currentClausula = false
    let allTrue = true

    //Checa se não é o último assignment
    /*if (assignment.last == true) {
      last = true
    }*/
    
    //Checa o assignment atual
    //checa todos as clausulas
    let sentenca = new Array(clauses.length)
    for (let j = 0; (j < clauses.length) & (allTrue); j++) {
      //checa a clausula atual
      let currentClausula = false
      let pelomenosuma = false 
      for (let i = 0; i < clauses[j].length & !(currentClausula); i++) {

        if (assignment[Math.abs(clauses[j][i]) - 1] == 0) {
          if (clauses[j][i] < 0) {
            currentClausula = true
            pelomenosuma = true
          }
        }
        else {
          if (clauses[j][i] > 0) {
            currentClausula = true
            pelomenosuma = true
          }
        }

        if (!currentClausula & i == clauses[j].length - 1 & !pelomenosuma) {
          allTrue = false
        }
      }
      currentClausula = false
      if (pelomenosuma) {
        sentenca[j] = true
      }
    }
    if (allTrue) {
      isSat = true
    }
    else if (last) {
      isSat = false
    }
    // if not, get the next assignment and try again.
    else if(!last){
      assignment = nextAssignment(assignment)
    }
  }

  if (isSat) {
    let result = { isSat: true, satisfyingAssignment: assignment }
    return result
  }
  else{
    let result = { isSat: false, satisfyingAssignment: null }
    return result
  }

}

// Receives the current assignment and produces the next one
function nextAssignment(currentAssignment) {
  let newAssignment = currentAssignment
  for (let g = newAssignment.length - 1; g >= 0; g--) {
    if (newAssignment[g] == 0) {
      newAssignment[g] = 1
      return newAssignment
    }
    else{
      newAssignment[g] = 0
    }
  }
}



//---------------------------------------------------------------------DO NOT TOUCH--------------------------------------------------------------------------//

function readFormula(String) {
  var arqv = String


  let text = fs.readFileSync('C:/Users/marco/Desktop/castor/ProjetoIC/' + arqv + '.cnf', 'utf8').split(/[\r\n]+/)
  let variables = readVariables(text)
  let resultado

  if (variables == 'false') {
    let clauses = readClauses(text, false)
    variables = readVariables(clauses.maior);
    resultado = { clauses: clauses.clauses, variables: variables }
    return resultado
  }
  else {
    let linhas = text
    let clauses = readClauses(linhas, true)
    let specOk = checkProblemSpecification(text, clauses, variables)

    if (specOk) {
      resultado = { clauses: clauses, variables: variables }
      return resultado
    }
    else {
      return 'Especificação do problema incorreta.'
    }
  }
}

function readVariables(text) {
  let achou = false
  let variablesNovo = []

  if (typeof (text) == 'string') {
    for (iPre = 0; iPre < text; iPre++) {
      variablesNovo.push(0);
    }
    return variablesNovo
  }
  else {
    //Percorre o text em busca da linha começando por 'p'
    for (let i = 0; i < text.length && !achou; i++) {
      if (text[i].charAt(0) == 'p') {
        achou = true
        let dividido = text[i].split(" ")
        //Se a posição 2 de 'dividido' conter um número, faça:
        if (!isNaN(dividido[2])) {
          //Define o tamanho do array de variáveis a ser retornado
          //Preenche o array com 0, até o fim de seu tamanho.
          for (iPre = 0; iPre < dividido[2]; iPre++) {
            variablesNovo.push(0);
          }
        }
      }
    }
    if (achou) {
      //retorna 'VariablesNovo' como definição de 'variables'
      return variablesNovo
    }
    else {
      return false
    }
  }
}

function readClauses(text, LP) {

  if (LP == false) {
    let clausulas = []
    let maior = 0

    for (let i = 0; i < text.length; i++) {
      //Precisamos definir as clausulas, então procuramos a proxima
      //linha que contenha um inteiro (isso para todas as linhas de clausula)
      if (!(text[i].charAt(0) == 'p') & !(text[i].charAt(0) == 'c')) {
        if (!isNaN(text[i].charAt(0)) | !isNaN(text[i].charAt(1))) {
          for (let j = i, temp = ""; j < text.length; j++) {
            //Definimos que a linha de cláusula atual é aquela que estamos em 'j'
            let linhaatual = temp + text[j]
            if (linhaatual.charAt(linhaatual.length - 1) == '0') {
              linhaatual = linhaatual.split(" ")

              //Dentro das cláusulas, verifica qual o maior número (que representa a quantidade de variáveis, e monta o array)
              for (let m = 0; m < linhaatual.length; m++) {
                if (Math.abs(parseInt(linhaatual[m])) > parseInt(maior)) {
                  maior = Math.abs(parseInt(linhaatual[m]))
                }
              }

              let arrayzinho = []
              for (let k = 0; k < linhaatual.length - 1; k++) {
                arrayzinho.push(linhaatual[k])
              }
              clausulas.push(arrayzinho)
              temp = ""
            }
            else {
              temp = temp + linhaatual + " "
            }
          }
          let retorno = {
            clauses: clausulas, maior: maior
          }
          return retorno
        }
      }
    }
  }
  else {
    let clausulas = []
    //Percorre o text em busca da linha começando por 'p'
    for (let i = 0; i < text.length; i++) {
      //Precisamos definir as clausulas, então procuramos a proxima
      //linha que contenha um inteiro (isso para todas as linhas de clausula)
      if (!(text[i].charAt(0) == 'p') & !(text[i].charAt(0) == 'c')) {
        if (!isNaN(text[i].charAt(0)) | !isNaN(text[i].charAt(1))) {
          for (let j = i, temp = ""; j < text.length; j++) {
            //Definimos que a linha de cláusula atual é aquela que estamos em 'j'
            let linhaatual = temp + text[j]
            //Se o final da linha que estamos conter '0', ou seja, divisão, fazemos que:
            if (linhaatual.charAt(linhaatual.length - 1) == '0') {
              //A variável linhaatual vira um Array, dividido por espaços
              linhaatual = linhaatual.split(" ")
              //Percorreremos cada posoção da linha dividida por espaços, até seu fim, e chamamos a função para
              //push em clausulas[]
              let arrayzinho = []
              for (let k = 0; k < linhaatual.length - 1; k++) {
                arrayzinho.push(linhaatual[k])
              }
              clausulas.push(arrayzinho)
              temp = ""
            }
            else {
              temp = temp + linhaatual + " "
            }
          }
          return clausulas
        }
      }

    }
  }


}

function checkProblemSpecification(linhas, clauses, variables) {
  let dividido
  let maior = 0
  let achou = false

  for (let m = 0; m < linhas.length; m++) {
    if( !(linhas[m].charAt(0) == 'p') & !(linhas[m].charAt(0) == 'c')  ){
    dividido = linhas[m].split(" ")
    
      for(let n = 0; n < dividido.length; n++){
        
        if (Math.abs(parseInt(dividido[n])) > parseInt(maior)) {
          maior = Math.abs(parseInt(dividido[n]))  
        }

      }

    }
  }

  for (let i = 0; i < linhas.length & achou == false; i++) {
    if (linhas[i].charAt(0) == 'p') {
      dividido = linhas[i].split(" ")
      achou = true
    }
  }

  if (achou) {
    if ((dividido[3] == clauses.length) & (maior == variables.length)) {
      return true
    }
    else {
      return false
    }
  }
  else {
    return false
  }
}






